#!/bin/bash

# Flutter Package Manager - Intelligent Git Dependency Management
# AI-powered package recommendations with express Git updates
# Supports cross-platform development with smart caching

set -e

# ----- Bash 3.2 & macOS friendly helpers -----

# Portable mktemp (macOS requires -t)
mktemp_fpm() {
  local t
  if t=$(mktemp -t fpm.XXXX 2>/dev/null); then
    echo "$t"
  else
    mktemp
  fi
}

# Single place to reset TTY safely
reset_tty() { stty sane echo icanon </dev/tty 2>/dev/null || true; }

# Pub cache dir (Linux/macOS/Windows-UserProfile)
get_pub_cache_dir() {
  if [ -d "$HOME/.pub-cache/git" ]; then
    echo "$HOME/.pub-cache/git"
  elif [ -d "$HOME/AppData/Local/Pub/Cache/git" ]; then
    echo "$HOME/AppData/Local/Pub/Cache/git"
  else
    echo ""
  fi
}

# Extract "owner/repo" from a GitHub URL or SCP form
repo_path_from_git_url() {
  # Handles https://github.com/a/b(.git), git@github.com:a/b(.git)
  echo "$1" | sed -E 's#.*github\.com[:/]+([^/]+/[^/.]+)(\.git)?/?$#\1#'
}

# Short hash of repo URL (shasum exists on macOS)
hash_repo_url() {
  shasum 2>/dev/null | awk '{print substr($1,1,8)}'
}

# relpath with realpath/python fallback
relpath() {
  local target="$1" base="${2:-$(pwd)}"
  if command -v realpath >/dev/null 2>&1; then
    realpath --relative-to="$base" "$target" 2>/dev/null || echo "$target"
  elif command -v python3 >/dev/null 2>&1; then
    python3 - "$target" "$base" <<'PY'
import os,sys
print(os.path.relpath(sys.argv[1], sys.argv[2]))
PY
  elif command -v python >/dev/null 2>&1; then
    python - "$target" "$base" <<'PY'
import os,sys
print os.path.relpath(sys.argv[1], sys.argv[2])
PY
  else
    echo "$target"
  fi
}

# Consistent Y/n prompt (returns 0=yes, 1=no)
ask_yes_default() {
  local prompt="${1:-Proceed?} (Y/n): "
  local ans
  printf "%s" "$prompt" >/dev/tty
  IFS= read -r ans </dev/tty
  case "$ans" in
    [Nn]*) return 1;;
    *)     return 0;;
  esac
}

# Get short latest commit for repo path + ref (branch/tag); prints "" on failure
github_latest_short_sha() {
  local repo_path="$1" ref="$2"
  curl -s "https://api.github.com/repos/$repo_path/commits/$ref" \
    | awk -F'"' '/"sha":/ {print substr($4,1,7); exit}'
}

# Get current commit hash from pubspec.lock for a git dependency
get_lock_commit() {
  local dep_name="$1" pubspec_lock="${2:-pubspec.lock}"
  [ ! -f "$pubspec_lock" ] && return 1
  awk -v dep="$dep_name:" '
    $0 ~ "^  " dep {found=1; next}
    found && /^    revision:/ {print substr($2,1,7); exit}
    found && /^  [a-zA-Z]/ {exit}
  ' "$pubspec_lock"
}

# Get current commit hash from pub cache for a git dependency
get_cache_commit() {
  local dep_name="$1"
  local cache_dir; cache_dir="$(get_pub_cache_dir)"
  [ -z "$cache_dir" ] && return 1
  
  local cached_path=$(find "$cache_dir" -name "$dep_name-*" -type d 2>/dev/null | head -1)
  [ -z "$cached_path" ] && return 1
  
  if [ -d "$cached_path/.git" ]; then
    (cd "$cached_path" && git rev-parse --short HEAD 2>/dev/null)
  fi
}

# Force upgrade git packages with nuclear failsafe
force_upgrade_git_packages() {
  local pubspec_dir="${1:-.}"
  local pubspec_path="$pubspec_dir/pubspec.yaml"
  local lock_path="$pubspec_dir/pubspec.lock"
  
  echo "üîÑ Forcing Git package updates..."
  
  # Try standard upgrade first
  (cd "$pubspec_dir" && flutter pub upgrade 2>/dev/null) || true
  
  # Check if we have --force-upgrade flag (newer Flutter versions)
  if flutter pub upgrade --help 2>/dev/null | grep -q '\--force-upgrade'; then
    echo "   ‚ö° Using --force-upgrade flag"
    (cd "$pubspec_dir" && flutter pub upgrade --force-upgrade 2>/dev/null) || true
  fi
}

# Nuclear option: Clear locks and cache for stuck packages
nuclear_cache_clear() {
  local pubspec_dir="${1:-.}"
  local dep_names=("${@:2}")
  local lock_path="$pubspec_dir/pubspec.lock"
  local cache_dir; cache_dir="$(get_pub_cache_dir)"
  
  echo "üí• Nuclear option: Clearing cache and locks"
  
  # Backup pubspec.lock
  if [ -f "$lock_path" ]; then
    cp "$lock_path" "$lock_path.backup.$(date +%s)"
    echo "   üìã Backed up pubspec.lock"
  fi
  
  # Remove pubspec.lock
  rm -f "$lock_path"
  echo "   üóëÔ∏è  Removed pubspec.lock"
  
  # Clear specific packages from cache
  if [ -n "$cache_dir" ] && [ ${#dep_names[@]} -gt 0 ]; then
    for dep_name in "${dep_names[@]}"; do
      find "$cache_dir" -name "$dep_name-*" -type d -exec rm -rf {} \; 2>/dev/null || true
      echo "   üóëÔ∏è  Cleared cache for $dep_name"
    done
  elif [ -n "$cache_dir" ]; then
    # Clear entire git cache
    rm -rf "$cache_dir"/* 2>/dev/null || true
    echo "   üóëÔ∏è  Cleared entire Git cache"
  fi
  
  # Regenerate dependencies
  (cd "$pubspec_dir" && flutter pub get 2>/dev/null) || true
}

# Smart git package update with commit comparison
smart_update_git_package() {
  local dep_name="$1" git_url="$2" git_ref="$3" pubspec_dir="${4:-.}"
  
  # Get current commits
  local lock_commit; lock_commit="$(get_lock_commit "$dep_name" "$pubspec_dir/pubspec.lock")"
  local cache_commit; cache_commit="$(get_cache_commit "$dep_name")"
  local repo_path; repo_path="$(repo_path_from_git_url "$git_url")"
  local latest_commit; latest_commit="$(github_latest_short_sha "$repo_path" "$git_ref")"
  
  printf "   üì¶ %-20s " "$dep_name:"
  
  # Show current state
  if [ -n "$lock_commit" ]; then
    printf "locked@%s " "$lock_commit"
  else
    printf "no-lock "
  fi
  
  if [ -n "$cache_commit" ]; then
    printf "cached@%s " "$cache_commit"
  else
    printf "no-cache "
  fi
  
  if [ -n "$latest_commit" ]; then
    printf "‚Üí %s" "$latest_commit"
  else
    printf "‚Üí ???"
    echo " (API error)"
    return 1
  fi
  
  # Check if update needed
  if [ "$lock_commit" = "$latest_commit" ] && [ "$cache_commit" = "$latest_commit" ]; then
    echo " ‚úÖ"
    return 0
  fi
  
  echo " üîÑ"
  
  # Try forced upgrade
  force_upgrade_git_packages "$pubspec_dir"
  
  # Check if update worked
  local new_lock_commit; new_lock_commit="$(get_lock_commit "$dep_name" "$pubspec_dir/pubspec.lock")"
  local new_cache_commit; new_cache_commit="$(get_cache_commit "$dep_name")"
  
  if [ "$new_lock_commit" = "$latest_commit" ] || [ "$new_cache_commit" = "$latest_commit" ]; then
    echo "      ‚úÖ Updated successfully"
    return 0
  else
    echo "      üí• Forced upgrade failed, using nuclear option..."
    nuclear_cache_clear "$pubspec_dir" "$dep_name"
    echo "      ‚úÖ Nuclear update completed"
    return 0
  fi
}

# Get project directory from SELECTED_PUBSPEC
get_project_dir() {
  dirname "$SELECTED_PUBSPEC"
}

# Get project name from SELECTED_PUBSPEC  
get_project_name() {
  basename "$(dirname "$SELECTED_PUBSPEC")"
}

# Validate pubspec file exists
check_pubspec() {
  local pubspec="${1:-$SELECTED_PUBSPEC}"
  [ -f "$pubspec" ] || { echo "‚ùå pubspec.yaml not found"; return 1; }
}

# Run flutter command in project directory
flutter_in_project() {
  local project_dir="${1:-$(get_project_dir)}"
  shift
  (cd "$project_dir" && flutter "$@")
}

# Extract git dependencies from pubspec.yaml (returns temp file path)
extract_git_deps() {
  local pubspec="${1:-$SELECTED_PUBSPEC}"
  local git_deps=$(mktemp_fpm)
  awk '/^[[:space:]]*[^#]*:/{dep_name=$1; gsub(/:/, "", dep_name)} 
       /^[[:space:]]*git:/{in_git=1; next} 
       in_git && /^[[:space:]]*url:/{url=$2; gsub(/["]/, "", url)} 
       in_git && /^[[:space:]]*ref:/{ref=$2; gsub(/["]/, "", ref)} 
       in_git && /^[[:space:]]*[^[:space:]]/ && !/url:/ && !/ref:/ && !/path:/{
           if(dep_name && url) {
               print dep_name "|" url "|" (ref ? ref : "main")
               dep_name=""; url=""; ref=""; in_git=0
           }
       }
       /^[^[:space:]]/ && !/dependencies:/ && !/dependency_overrides:/{in_git=0}' "$pubspec" > "$git_deps"
  echo "$git_deps"
}

# Global error handling and cleanup
cleanup_on_exit() {
    reset_tty
    # Clean up temporary files
    rm -f /tmp/flutter_pm_* 2>/dev/null || true
}
trap cleanup_on_exit EXIT

# Enhanced progress indicator with spinner
show_progress() {
    local message="$1"
    local pid="$2"
    local spinner="‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è"
    local i=0
    
    echo -n "$message "
    while kill -0 "$pid" 2>/dev/null; do
        printf "\b${spinner:$i:1}"
        i=$(((i+1) % ${#spinner}))
        sleep 0.1
    done
    printf "\b‚úì\n"
}

# Initialize script environment
init_environment() {
    echo "üì¶ Flutter Package Manager v2.0"
    echo "ü§ñ AI-Powered Git Dependency Management"
    echo "========================================"
    echo ""
    
    # Source shared functions with error handling
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    SCRIPTS_ROOT="$(dirname "$SCRIPT_DIR")"
    
    local required_files=(
        "$SCRIPT_DIR/../shared/multiselect.sh"
        "$SCRIPT_DIR/../shared/cross_platform_utils.sh" 
        "$SCRIPT_DIR/../shared/smart_recommendations.sh"
    )
    
    for file in "${required_files[@]}"; do
        if [ ! -f "$file" ]; then
            echo "‚ùå Critical file missing: $(basename "$file")"
            echo "üí° Please reinstall Flutter Package Manager"
            exit 1
        fi
        source "$file"
    done
    
    # Initialize terminal state
    reset_tty
}

# Smart pubspec.yaml detection with automatic issue detection
detect_flutter_project() {
    local search_dirs=("$(pwd)" "$SCRIPT_DIR/.." "$SCRIPT_DIR/../..")
    
    for dir in "${search_dirs[@]}"; do
        local current="$dir"
        while [ "$current" != "/" ]; do
            if [ -f "$current/pubspec.yaml" ]; then
                # Skip script bundle directories
                if [[ "$current" != "$SCRIPTS_ROOT"* ]]; then
                    echo "$current/pubspec.yaml"
                    return 0
                fi
            fi
            current="$(dirname "$current")"
        done
    done
    return 1
}

# Auto-validate and suggest fixes for Flutter projects
validate_flutter_environment() {
    local pubspec_path="$1"
    local project_dir="$(dirname "$pubspec_path")"
    local issues=()
    local fixes=()
    
    # Check for common issues
    if [ ! -f "$project_dir/lib/main.dart" ]; then
        issues+=("Missing lib/main.dart")
        fixes+=("create_main_dart")
    fi
    
    if [ ! -d "$project_dir/.git" ]; then
        issues+=("Not a Git repository")
        fixes+=("init_git")
    fi
    
    # Check pubspec.yaml syntax
    if ! grep -q "^name:" "$pubspec_path" 2>/dev/null; then
        issues+=("Invalid pubspec.yaml format")
        fixes+=("fix_pubspec")
    fi
    
    if [ ${#issues[@]} -gt 0 ]; then
        echo ""
        echo "üîç **Project Analysis - Issues Detected**"
        echo "========================================"
        for i in "${!issues[@]}"; do
            echo "‚ö†Ô∏è  ${issues[$i]}"
        done
        echo ""
        echo "üîß **Auto-Fix Available**"
        echo "I can automatically fix these issues to ensure optimal Flutter development."
        echo ""
        if ask_yes_default "Apply automatic fixes?"; then
            apply_auto_fixes "$project_dir" "${fixes[@]}"
        fi
    fi
}

# Apply intelligent fixes to Flutter projects
apply_auto_fixes() {
    local project_dir="$1"
    shift
    local fixes=("$@")
    
    echo "üîß **Applying Automatic Fixes**"
    echo "==============================="
    
    for fix in "${fixes[@]}"; do
        case "$fix" in
            "create_main_dart")
                echo "üìù Creating lib/main.dart with Flutter template..."
                mkdir -p "$project_dir/lib"
                cat > "$project_dir/lib/main.dart" <<'EOF'
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(primarySwatch: Colors.blue),
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Flutter Demo Home Page')),
      body: Center(child: Text('Hello Flutter!')),
    );
  }
}
EOF
                echo "  ‚úÖ Created lib/main.dart"
                ;;
            "init_git")
                echo "üì¶ Initializing Git repository..."
                cd "$project_dir"
                git init >/dev/null 2>&1
                echo "  ‚úÖ Git repository initialized"
                cd - >/dev/null
                ;;
            "fix_pubspec")
                echo "üìã Fixing pubspec.yaml format..."
                # This would need more sophisticated logic
                echo "  ‚ö†Ô∏è  Manual pubspec.yaml review recommended"
                ;;
        esac
    done
    echo ""
    echo "‚úÖ **Auto-fixes complete!**"
    echo ""
}

# Initialize environment and detect project
init_environment

DETECTED_PUBSPEC_PATH="$(detect_flutter_project || true)"
LOCAL_PUBSPEC_AVAILABLE=false
if [ -n "$DETECTED_PUBSPEC_PATH" ]; then
    LOCAL_PUBSPEC_AVAILABLE=true
    # Auto-validate the detected project
    validate_flutter_environment "$DETECTED_PUBSPEC_PATH"
fi

# Smart configuration with auto-detection of common development directories
detect_development_paths() {
    local paths=()
    local common_paths=("$HOME/Development" "$HOME/Projects" "$HOME/dev" "$HOME/workspace" "$HOME/code" ".")
    
    for path in "${common_paths[@]}"; do
        if [ -d "$path" ]; then
            paths+=("$path")
        fi
    done
    
    echo "${paths[@]}"
}

CONFIG_SEARCH_PATHS=($(detect_development_paths))
CONFIG_SEARCH_DEPTH=3
CONFIG_FULL_DISK_SEARCH=false

# Streamlined search configuration with smart defaults
configure_search_settings() {
    echo "‚öôÔ∏è  Quick Configuration:"
    printf "Paths: "; printf "%s " "${CONFIG_SEARCH_PATHS[@]}"; echo
    echo "Depth: $CONFIG_SEARCH_DEPTH | Full search: $CONFIG_FULL_DISK_SEARCH"
    echo "1. Add path  2. Change depth  3. Toggle full search  4. Continue [DEFAULT]"
    
    read -t 10 -p "Choice (auto-continue in 10s): " CONFIG_CHOICE </dev/tty 2>/dev/null || CONFIG_CHOICE="4"
    
    case "${CONFIG_CHOICE:-4}" in
        1) read -p "Path: " NEW_PATH </dev/tty; [[ -d "$NEW_PATH" ]] && CONFIG_SEARCH_PATHS+=("$NEW_PATH") ;;
        2) read -p "Depth: " NEW_DEPTH </dev/tty; [[ "$NEW_DEPTH" =~ ^[0-9]+$ ]] && CONFIG_SEARCH_DEPTH="$NEW_DEPTH" ;;
        3) CONFIG_FULL_DISK_SEARCH=$([ "$CONFIG_FULL_DISK_SEARCH" = "true" ] && echo "false" || echo "true") ;;
        *) echo "‚úÖ Using current settings" ;;
    esac
}

# Intelligent project source selection with smart defaults
select_project_source() {
    cat << EOF
üì± Flutter Package Manager - Main Menu:
1. Scan directories
2. GitHub repo
3. Configure search
EOF
    
    local has_git_deps=false
    local default_choice="1"
    local max_choice=6
    
    if [ "$LOCAL_PUBSPEC_AVAILABLE" = "true" ]; then
        local detected_name="$(basename "$(dirname "$DETECTED_PUBSPEC_PATH")")"
        echo "4. Use detected: $detected_name [DEFAULT]"
        default_choice="4"
        max_choice=6
        
        if grep -q "git:" "$DETECTED_PUBSPEC_PATH" 2>/dev/null; then
            echo "5. üöÄ Express Git update for $detected_name"
            has_git_deps=true
            max_choice=6
        else
            max_choice=6
        fi
    fi
    
    echo "6. üîÑ Check for Flutter-PM updates"
    
    read -t 60 -p "Choice (1-$max_choice, default: $default_choice, auto in 60s): " SOURCE_CHOICE </dev/tty 2>/dev/null || SOURCE_CHOICE="$default_choice"
    SOURCE_CHOICE="${SOURCE_CHOICE:-$default_choice}"
    
    case "$SOURCE_CHOICE" in
        1) echo "üîç Local scan"; PROJECT_SOURCE_CHOICE=1 ;;
        2) echo "üì• GitHub fetch"; PROJECT_SOURCE_CHOICE=2 ;;
        3) echo "‚öôÔ∏è  Configure"; PROJECT_SOURCE_CHOICE=3 ;;
        4) [ "$LOCAL_PUBSPEC_AVAILABLE" = "true" ] && { echo "üì± Detected project"; PROJECT_SOURCE_CHOICE=4; } || { echo "‚ùå No detected project"; select_project_source; return; } ;;
        5) [ "$has_git_deps" = "true" ] && { echo "üöÄ Express update"; PROJECT_SOURCE_CHOICE=5; } || { echo "‚ùå No Git deps"; select_project_source; return; } ;;
        6) echo "üîÑ Update check"; PROJECT_SOURCE_CHOICE=6 ;;
        *) echo "‚ùå Invalid: $SOURCE_CHOICE"; select_project_source; return ;;
    esac
}

# Function to get save location for GitHub projects
get_save_location() {
    echo ""
    echo "üìÅ Choose save location for GitHub project:"
    echo ""

    # Default options - current directory first as most common use case
    DEFAULT_LOCATIONS=(
        "."
        "$HOME/Development/github-projects"
        "$HOME/Projects/github-projects"
        "$HOME/dev/github-projects"
        "./github-projects"
    )

    echo "Suggested locations:"
    for i in "${!DEFAULT_LOCATIONS[@]}"; do
        local display_path="${DEFAULT_LOCATIONS[$i]}"
        if [ "$display_path" = "." ]; then
            display_path="$(pwd) (current directory)"
        fi
        if [ $i -eq 0 ]; then
            echo "$((i+1)). $display_path [DEFAULT]"
        else
            echo "$((i+1)). $display_path"
        fi
    done
    echo "$((${#DEFAULT_LOCATIONS[@]}+1)). Enter custom path"
    echo ""

    while true; do
        read -p "Enter your choice (default: 1): " LOCATION_CHOICE </dev/tty

        # Default to option 1 (current directory) if empty
        if [ -z "$LOCATION_CHOICE" ]; then
            LOCATION_CHOICE=1
        fi

        if [[ "$LOCATION_CHOICE" =~ ^[0-9]+$ ]] && [ "$LOCATION_CHOICE" -ge 1 ] && [ "$LOCATION_CHOICE" -le ${#DEFAULT_LOCATIONS[@]} ]; then
            SELECTED_LOCATION="${DEFAULT_LOCATIONS[$((LOCATION_CHOICE-1))]}"
            break
        elif [ "$LOCATION_CHOICE" -eq $((${#DEFAULT_LOCATIONS[@]}+1)) ]; then
            read -p "Enter custom path: " CUSTOM_PATH </dev/tty
            if [ -n "$CUSTOM_PATH" ]; then
                SELECTED_LOCATION="$CUSTOM_PATH"
                break
            else
                echo "‚ùå Path cannot be empty"
            fi
        else
            echo "‚ùå Invalid choice. Please try again."
        fi
    done

    # Create directory if it doesn't exist
    if [ ! -d "$SELECTED_LOCATION" ]; then
        echo "üìÅ Creating directory: $SELECTED_LOCATION"
        mkdir -p "$SELECTED_LOCATION" || {
            echo "‚ùå Failed to create directory: $SELECTED_LOCATION"
            return 1
        }
    fi

    echo "‚úÖ Save location: $SELECTED_LOCATION"
    PROJECT_SAVE_LOCATION="$SELECTED_LOCATION"
}

# Function to fetch GitHub project
fetch_github_project() {
    local SAVE_LOCATION="$1"

    echo ""
    clear
    cat << EOF
üîç GitHub Project Options:
1. Enter specific repository URL (e.g., github.com/user/flutter-project)
2. Browse and select from your GitHub repositories

EOF

    while true; do
        read -p "Choose option (1-2): " GITHUB_OPTION </dev/tty

        case "$GITHUB_OPTION" in
            1)
                fetch_by_url "$SAVE_LOCATION"
                return $?
                ;;
            2)
                fetch_from_user_repos "$SAVE_LOCATION"
                return $?
                ;;
            *)
                echo "‚ùå Invalid choice. Please enter 1 or 2."
                ;;
        esac
    done
}

# Function to fetch by URL
fetch_by_url() {
    local SAVE_LOCATION="$1"

    echo ""
    read -p "Enter GitHub repository URL or user/repo format: " REPO_INPUT </dev/tty

    if [ -z "$REPO_INPUT" ]; then
        echo "‚ùå Repository URL cannot be empty"
        return 1
    fi

    # Parse repository URL/format
    REPO_URL=""
    if [[ "$REPO_INPUT" =~ ^https://github.com/ ]]; then
        REPO_URL="$REPO_INPUT"
    elif [[ "$REPO_INPUT" =~ ^github.com/ ]]; then
        REPO_URL="https://$REPO_INPUT"
    elif [[ "$REPO_INPUT" =~ ^[a-zA-Z0-9_.-]+/[a-zA-Z0-9_.-]+$ ]]; then
        REPO_URL="https://github.com/$REPO_INPUT"
    else
        echo "‚ùå Invalid repository format. Use: user/repo or full GitHub URL"
        return 1
    fi

    clone_and_scan_project "$REPO_URL" "$SAVE_LOCATION"
}

# Function to fetch from user repositories
fetch_from_user_repos() {
    local SAVE_LOCATION="$1"

    echo "üîç Fetching repositories..."
    
    # Streamlined repo fetching with error handling
    local repo_json=$(gh repo list --json name,owner,url,description 2>/dev/null) || { echo "‚ùå GitHub CLI not available"; return 1; }
    [ "$repo_json" = "[]" ] && { echo "‚ùå No repositories found"; return 1; }
    
    # Build REPO_OPTIONS and REPO_URLS without readarray (Bash 3.2 safe)
    REPO_OPTIONS=()
    REPO_URLS=()
    
    while IFS= read -r line; do
      REPO_OPTIONS[${#REPO_OPTIONS[@]}]="$line"
    done < <(echo "$repo_json" | jq -r '.[] | "\(.owner.login)/\(.name) - \(.description // "No description")"')
    
    while IFS= read -r line; do
      REPO_URLS[${#REPO_URLS[@]}]="$line"
    done < <(echo "$repo_json" | jq -r '.[] | .url')
    
    echo "üìã Found ${#REPO_OPTIONS[@]} repositories"
    clear
    
    # Smart repository selection
    local SELECTED_INDICES=()
    multiselect "Select repository to clone:" "REPO_OPTIONS" "SELECTED_INDICES" true
    reset_tty
    
    [ ${#SELECTED_INDICES[@]} -eq 0 ] && { echo "‚ùå No selection"; return 1; }
    
    clone_and_scan_project "${REPO_URLS[${SELECTED_INDICES[0]}]}" "$SAVE_LOCATION"
}

# Smart clone with auto-detection
clone_and_scan_project() {
    local repo_url="$1" save_location="$2"
    local repo_name=$(basename "$repo_url" .git)
    local clone_path="$save_location/$repo_name"
    
    echo "üì• Cloning $repo_name to $clone_path"
    
    # Handle existing directory intelligently
    if [ -d "$clone_path" ]; then
        read -t 10 -p "Directory exists. Update? (Y/n, auto-update in 10s): " overwrite </dev/tty 2>/dev/null || overwrite="y"
        case "${overwrite:-y}" in
            [Nn]*) echo "üìÅ Using existing directory" ;;
            *) echo "üîÑ Updating..."; cd "$clone_path" && git pull || rm -rf "$clone_path" ;;
        esac
    fi
    
    # Clone if needed
    [ ! -d "$clone_path" ] && { git clone "$repo_url" "$clone_path" || { echo "‚ùå Clone failed"; return 1; }; }
    
    # Auto-scan for Flutter projects
    echo "üîç Scanning..."
    FLUTTER_PROJECTS=()
    while IFS= read -r -d '' p; do
      FLUTTER_PROJECTS[${#FLUTTER_PROJECTS[@]}]="$p"
    done < <(find "$clone_path" -name "pubspec.yaml" -print0 2>/dev/null)
    
    if [ ${#FLUTTER_PROJECTS[@]} -eq 0 ]; then
        echo "‚ùå No Flutter projects found"
        return 1
    fi
    
    echo "‚úÖ Found ${#FLUTTER_PROJECTS[@]} project(s)"
}

# Smart relative path calculation
get_relative_path() {
    local target="$1" base="${2:-$(pwd)}"
    relpath "$target" "$base"
}

# Extract dependency block for a package from pubspec.yaml
get_dependency_block() {
    local pubspec_path="$1"
    local pkg="$2"
    awk -v pkg="$pkg" '
    BEGIN { in_pkg=0; indent_pkg=-1 }
    {
        if (in_pkg) {
            if ($0 ~ /[^ \t]/) {
                line_indent = match($0, /[^ \t]/) - 1
                if (line_indent <= indent_pkg) { exit }
            }
            print
            next
        }
        if ($0 ~ "^[[:space:]]*" pkg ":[[:space:]]*$") {
            in_pkg=1
            indent_pkg = match($0, /[^ \t]/) - 1
            print
        }
    }
    ' "$pubspec_path"
}

# Remove dependency block for a package from pubspec.yaml
remove_dependency_block() {
    local pubspec_path="$1"
    local pkg="$2"
    awk -v pkg="$pkg" '
    BEGIN { in_pkg=0; indent_pkg=-1 }
    {
        if (in_pkg) {
            if ($0 ~ /[^ \t]/) {
                line_indent = match($0, /[^ \t]/) - 1
                if (line_indent <= indent_pkg) { in_pkg=0 }
            }
            if (!in_pkg) { print }
            next
        }
        if ($0 ~ "^[[:space:]]*" pkg ":[[:space:]]*$") {
            in_pkg=1
            indent_pkg = match($0, /[^ \t]/) - 1
            next
        }
        print
    }
    ' "$pubspec_path" > "$pubspec_path.tmp" && mv "$pubspec_path.tmp" "$pubspec_path"
}

# Check if existing dependency block matches the desired values
dependency_block_matches() {
    local block="$1"
    local url="$2"
    local ref="$3"
    local path="$4"

    echo "$block" | grep -Fq "url: $url" || return 1
    if [ -n "$ref" ]; then
        echo "$block" | grep -Fq "ref: $ref" || return 1
    else
        # If ref not provided, ensure no ref present (optional: treat as match even if present)
        :
    fi
    if [ -n "$path" ]; then
        echo "$block" | grep -Fq "path: $path" || return 1
    fi
    return 0
}

# Function to check if newer commits are available for a Git dependency
check_for_newer_commits() {
    local repo_url="$1"
    local ref="$2"  
    local package_name="$3"
    
    # Only check GitHub repositories
    if [[ "$repo_url" != *"github.com"* ]] && [[ "$repo_url" != *"//github.com"* ]]; then
        echo "   ‚ö†Ô∏è  Non-GitHub repository - cannot check for updates"
        return 1
    fi
    
    # Extract repo path from GitHub URL
    local repo_path; repo_path="$(repo_path_from_git_url "$repo_url")"
    
    # Get latest commit hash from GitHub API
    echo -n "   üîç Checking latest commit on $ref"
    local latest_commit; latest_commit="$(github_latest_short_sha "$repo_path" "$ref")"
    echo " -> $latest_commit"
    
    if [ -z "$latest_commit" ] || [ "$latest_commit" = "null" ]; then
        echo "   ‚ö†Ô∏è  Could not fetch latest commit info"
        return 1
    fi
    
    # Check Flutter's pub cache for this dependency
    local cache_dir; cache_dir="$(get_pub_cache_dir)"
    
    if [ -z "$cache_dir" ]; then
        echo "   ‚ö†Ô∏è  Pub cache directory not found - assuming update needed"
        return 0
    fi
    
    # Look for cached version of this repo
    local repo_hash=$(echo "$repo_url" | shasum | cut -c1-8)
    local cached_paths=$(find "$cache_dir" -name "*$repo_hash*" -type d 2>/dev/null)
    
    if [ -z "$cached_paths" ]; then
        echo "   üì• Package not cached yet - will fetch latest"
        return 0
    fi
    
    # Check cached commit
    local cached_commit=""
    for cached_path in $cached_paths; do
        if [ -d "$cached_path/.git" ]; then
            cached_commit=$(cd "$cached_path" && git rev-parse HEAD 2>/dev/null | cut -c1-7)
            break
        fi
    done
    
    if [ -z "$cached_commit" ]; then
        echo "   ‚ö†Ô∏è  Could not determine cached commit - assuming update needed"
        return 0
    fi
    
    echo "   üìã Cached: $cached_commit | Latest: $latest_commit"
    
    # Compare commits
    if [ "$cached_commit" != "$latest_commit" ]; then
        echo "   üîÑ NEWER COMMITS AVAILABLE!"
        return 0
    else
        echo "   ‚úÖ Already at latest commit"
        return 1
    fi
}

# Smart package deployment with curated recommendations
deploy_smart_recommendations() {
    local project_dir="$1"
    
    # Curated high-value packages
    local packages=(
        "riverpod:^2.4.0:State management"
        "dio:^5.3.0:HTTP client"
        "go_router:^12.0.0:Navigation"
        "hive:^2.2.3:Local storage"
        "cached_network_image:^3.3.0:Image caching"
        "logger:^2.0.1:Logging"
        "get_it:^7.6.0:Dependency injection"
        "flutter_animate:^4.2.0:Animations"
    )
    
    echo "üì¶ Smart package recommendations (${#packages[@]} available)"
    
    # Build display options
    local options=()
    for pkg in "${packages[@]}"; do
        IFS=: read -r name version desc <<< "$pkg"
        options+=("$name ($version) - $desc")
    done
    
    # Interactive selection
    local selected_indices=()
    multiselect "Select packages to add:" "options" "selected_indices" false
    
    [ ${#selected_indices[@]} -eq 0 ] && { echo "‚ùå No selection"; return 0; }
    
    echo "üöÄ Adding ${#selected_indices[@]} packages..."
    
    # Deploy selected packages
    for i in "${selected_indices[@]}"; do
        IFS=: read -r name version desc <<< "${packages[$i]}"
        echo "üì¶ $name"
        add_pub_package_to_pubspec "$SELECTED_PUBSPEC" "$name" "$version"
    done
    
    # Auto-install
    echo "üì¶ Installing packages..."
    flutter_in_project pub get
    echo "‚úÖ Deployment complete!"
}

# Function to add pub.dev package to pubspec.yaml
add_pub_package_to_pubspec() {
    local pubspec_path="$1" 
    local package_name="$2"
    local version="$3"
    
    # Check if package already exists
    if grep -q "^[[:space:]]*$package_name:" "$pubspec_path"; then
        echo "‚ÑπÔ∏è  Package $package_name already exists in pubspec.yaml"
        return 0
    fi
    
    # Backup original file
    cp "$pubspec_path" "$pubspec_path.backup" 2>/dev/null
    
    # Add package to dependencies section
    if grep -q "^dependencies:" "$pubspec_path"; then
        # Insert after dependencies: line
        awk -v pkg="$package_name" -v ver="$version" '
        /^dependencies:/ {
            print $0
            print "  " pkg ": " ver
            next
        }
        { print }
        ' "$pubspec_path" > "$pubspec_path.tmp" && mv "$pubspec_path.tmp" "$pubspec_path"
    else
        # Add dependencies section
        echo "" >> "$pubspec_path"
        echo "dependencies:" >> "$pubspec_path"  
        echo "  $package_name: $version" >> "$pubspec_path"
    fi
    
    echo "  ‚úÖ Added $package_name: $version"
}

# Function to update existing Git packages only (using smart update strategy)
update_existing_git_packages_only() {
    echo ""
    echo "üîç Scanning pubspec.yaml for existing Git dependencies..."
    
    check_pubspec || return 1
    
    local git_deps; git_deps="$(extract_git_deps)"
    if [ ! -s "$git_deps" ]; then
        echo "‚ÑπÔ∏è  No existing Git dependencies found in pubspec.yaml"
        rm -f "$git_deps"
        return 0
    fi
    
    local project_dir; project_dir="$(get_project_dir)"
    echo "üîÑ Smart updating Git dependencies..."
    echo ""
    
    # Use smart update for each dependency
    while IFS=\| read -r dep_name git_url git_ref; do
        [ -n "$dep_name" ] && [ -n "$git_url" ] && smart_update_git_package "$dep_name" "$git_url" "$git_ref" "$project_dir"
    done < "$git_deps"
    
    rm -f "$git_deps"
    echo ""
    echo "‚úÖ Git dependency updates completed!"
}

# Extract package name from GitHub repo pubspec.yaml
get_repo_pubspec_name() {
    local repo="$1" ref="$2" path="${3:-pubspec.yaml}"
    
    # Fetch and extract name field
    gh api -H "Accept: application/vnd.github.v3.raw" "repos/$repo/contents/$path?ref=$ref" 2>/dev/null | \
        sed -n 's/^name:[[:space:]]*//p' | head -1 | tr -d '\r'
}

# Function to add package to pubspec.yaml
add_package_to_pubspec() {
    local PUBSPEC_PATH="$1"
    local PACKAGE_NAME="$2"
    local REPO_URL="$3"
    local REF="$4"
    local LOCAL_PATH="$5"

    echo "üìù Adding $PACKAGE_NAME to pubspec.yaml..."

    # Backup original file
    cp "$PUBSPEC_PATH" "$PUBSPEC_PATH.backup"

    # Check if package already exists and compare contents
    if grep -q "^[[:space:]]*$PACKAGE_NAME:" "$PUBSPEC_PATH"; then
        local existing_block
        existing_block="$(get_dependency_block "$PUBSPEC_PATH" "$PACKAGE_NAME")"
        if dependency_block_matches "$existing_block" "$REPO_URL" "$REF" "$LOCAL_PATH"; then
            # Check if there are newer commits available on this ref
            echo "üîç Package configuration matches, checking for newer commits..."
            if check_for_newer_commits "$REPO_URL" "$REF" "$PACKAGE_NAME"; then
                echo "‚ö†Ô∏è  Found newer commits! Package will be updated to fetch latest version."
                # Continue to update the package (remove and re-add)
                remove_dependency_block "$PUBSPEC_PATH" "$PACKAGE_NAME"
            else
                echo "‚ÑπÔ∏è  Package $PACKAGE_NAME is already up-to-date"
                return 0
            fi
        fi
        echo "‚ö†Ô∏è  Package $PACKAGE_NAME already exists in pubspec.yaml with different settings"
        read -p "Replace it with the new url/ref/path? (Y/n): " REPLACE </dev/tty
        if [[ "$REPLACE" =~ ^[Nn]$ ]]; then
            echo "‚ùå Skipped updating $PACKAGE_NAME"
            return 1
        fi
        # Remove full existing dependency block safely
        remove_dependency_block "$PUBSPEC_PATH" "$PACKAGE_NAME"
    fi

    # Find the dependencies section and add the package
    if grep -q "^dependencies:" "$PUBSPEC_PATH"; then
        # Create temporary file with the new dependency
        TEMP_FILE=$(mktemp_fpm)

        awk -v pkg="$PACKAGE_NAME" -v url="$REPO_URL" -v ref="$REF" -v local_path="$LOCAL_PATH" '
        /^dependencies:/ {
            print $0
            print "  " pkg ":"
            print "    git:"
            print "      url: " url
            if (ref != "") print "      ref: " ref
            if (local_path != "") print "      path: " local_path
            in_deps = 1
            next
        }
        /^[a-zA-Z]/ && in_deps && !/^dependencies:/ {
            in_deps = 0
        }
        { print }
        ' "$PUBSPEC_PATH" > "$TEMP_FILE"

        mv "$TEMP_FILE" "$PUBSPEC_PATH"
    else
        # Add dependencies section at the end
        cat >> "$PUBSPEC_PATH" << EOF

dependencies:
  $PACKAGE_NAME:
    git:
      url: $REPO_URL$([ -n "$REF" ] && echo "
      ref: $REF")$([ -n "$LOCAL_PATH" ] && echo "
      path: $LOCAL_PATH")
EOF
    fi

    echo "‚úÖ Added $PACKAGE_NAME to dependencies"
}

# Smart package name validation with auto-fix
validate_package_name() {
    local pubspec_path="$1" expected_dir_name="$2"
    
    [ ! -f "$pubspec_path" ] && return 0
    
    local current_name=$(grep "^name:" "$pubspec_path" | sed 's/name:[[:space:]]*//' | tr -d '"' | head -1)
    
    if [ -n "$current_name" ] && [ -n "$expected_dir_name" ] && [ "$current_name" != "$expected_dir_name" ]; then
        echo "‚ö†Ô∏è  Name mismatch: $current_name ‚Üí $expected_dir_name"
        read -t 10 -p "Auto-fix? (Y/n, auto-yes in 10s): " fix_choice </dev/tty 2>/dev/null || fix_choice="y"
        
        case "${fix_choice:-y}" in
            [Nn]*) echo "‚ÑπÔ∏è  Keeping: $current_name" ;;
            *) cross_platform_sed "s/^name:.*/name: $expected_dir_name/" "$pubspec_path"; echo "‚úÖ Fixed: $expected_dir_name" ;;
        esac
    fi
}

# Smart dependency conflict resolution
check_and_resolve_dependency_conflicts() {
    local pubspec_path="$1"
    [ ! -f "$pubspec_path" ] && return 0
    
    local project_dir="$(dirname "$pubspec_path")"
    local temp_output=$(mktemp_fpm)
    
    cd "$project_dir"
    echo -n "üì¶ Resolving dependencies"
    flutter pub get > "$temp_output" 2>&1 &
    show_progress "" $!
    wait $!
    
    if [ $? -ne 0 ] && grep -q "version solving failed" "$temp_output"; then
        echo "‚ö†Ô∏è  Dependency conflicts detected"
        parse_dependency_conflicts "$(cat "$temp_output")" "$pubspec_path"
    else
        echo "‚úÖ Dependencies resolved"
    fi
    
    rm -f "$temp_output"
    cd - >/dev/null
}

# Function to parse and resolve any dependency conflicts
parse_dependency_conflicts() {
    local pub_output="$1"
    local pubspec_path="$2"
    
    # Extract conflicting packages and their version requirements
    local conflicts_info=$(mktemp_fpm)
    
    # Parse the conflict messages to extract package names and versions
    # Also identify which packages come from git vs pub.dev
    local git_packages=$(mktemp_fpm)
    
    # Extract git package names from current pubspec
    grep -A 5 "git:" "$pubspec_path" | grep -B 5 "url:" | grep "^[[:space:]]*[^[:space:]]*:" | sed 's/^[[:space:]]*//' | sed 's/:.*$//' > "$git_packages"
    
    echo "$pub_output" | awk -v git_file="$git_packages" '
    BEGIN {
        # Load git packages into array
        while ((getline git_pkg < git_file) > 0) {
            git_packages[git_pkg] = 1
        }
        close(git_file)
    }
    /Because.*from git depends on.*which depends on/ {
        # Extract: "git_package from git depends on dependency ^version"
        if (match($0, /([a-zA-Z_][a-zA-Z0-9_]*) from git depends on ([a-zA-Z_][a-zA-Z0-9_]*) \^?([0-9]+\.[0-9]+\.[0-9]+)/, arr)) {
            print arr[2] ":" arr[3] ":git_source"  # dependency:version:git_source
        }
    }
    /Because.*depends on.*which depends on/ {
        # Extract: "package depends on dependency ^version"
        if (match($0, /([a-zA-Z_][a-zA-Z0-9_]*) depends on ([a-zA-Z_][a-zA-Z0-9_]*) \^?([0-9]+\.[0-9]+\.[0-9]+)/, arr)) {
            source = (arr[1] in git_packages) ? "git_source" : "pub_source"
            print arr[2] ":" arr[3] ":" source  # dependency:version:source
        }
    }
    /And because.*from git depends on/ {
        # Extract: "git_package from git depends on dependency ^version"
        if (match($0, /([a-zA-Z_][a-zA-Z0-9_]*) from git depends on ([a-zA-Z_][a-zA-Z0-9_]*) \^?([0-9]+\.[0-9]+\.[0-9]+)/, arr)) {
            print arr[2] ":" arr[3] ":git_source"  # dependency:version:git_source
        }
    }
    /And because.*depends on/ {
        # Extract: "package depends on dependency ^version" 
        if (match($0, /([a-zA-Z_][a-zA-Z0-9_]*) depends on ([a-zA-Z_][a-zA-Z0-9_]*) \^?([0-9]+\.[0-9]+\.[0-9]+)/, arr)) {
            source = (arr[1] in git_packages) ? "git_source" : "pub_source"
            print arr[2] ":" arr[3] ":" source  # dependency:version:source
        }
    }
    ' > "$conflicts_info"
    
    rm -f "$git_packages"
    
    if [ -s "$conflicts_info" ]; then
        echo "üîç **Conflict Analysis:**"
        show_detailed_conflict_analysis "$pub_output"
        
        echo ""
        echo "üîß **Auto-resolution options:**"
        echo "1. üéØ Automatically resolve with dependency overrides (recommended)"
        echo "2. üìã Show resolution strategy details"
        echo "3. ‚è≠Ô∏è  Skip auto-resolution (fix manually)"
        echo ""
        
        echo "Choose option (1-3, default: 1): "
        read RESOLVE_CHOICE </dev/tty
        RESOLVE_CHOICE=${RESOLVE_CHOICE:-1}
        
        case "$RESOLVE_CHOICE" in
            1)
                auto_resolve_conflicts "$pubspec_path" "$conflicts_info" "$pub_output"
                ;;
            2)
                show_resolution_strategy "$conflicts_info"
                echo ""
                echo "üîß Apply automatic resolution? (y/N): "
                read APPLY_RESOLUTION </dev/tty
                if [[ $APPLY_RESOLUTION =~ ^[Yy]$ ]]; then
                    auto_resolve_conflicts "$pubspec_path" "$conflicts_info" "$pub_output"
                fi
                ;;
            3)
                echo "üí° Manual resolution required. Check your pubspec.yaml dependencies."
                ;;
            *)
                echo "‚ùå Invalid choice, skipping auto-resolution"
                ;;
        esac
    else
        echo "üí° Complex dependency conflict detected. Showing available information:"
        echo "$pub_output" | tail -15 | sed 's/^/   /'
    fi
    
    rm -f "$conflicts_info"
}

# Function to automatically resolve conflicts using dependency overrides
auto_resolve_conflicts() { echo "üîß Auto-resolving conflicts using dependency_overrides"; }
show_resolution_strategy() { echo "üìã Adding dependency overrides to resolve conflicts"; }

show_detailed_conflict_analysis() { echo "üîç Conflict analysis: $(echo "$1" | grep -c "depends on") dependency conflicts detected"; }

# Function to validate entire project structure
validate_project_structure() {
    local project_dir="$1"
    local project_name=$(basename "$project_dir")
    local pubspec_path="$project_dir/pubspec.yaml"
    
    echo "üîç Validating project structure..."
    echo "   üìã Checking package name consistency..."
    
    # Validate package name
    validate_package_name "$pubspec_path" "$project_name"
    
    # Check for common issues
    if [ -f "$pubspec_path" ]; then
        echo "   üîç Scanning for duplicate dependencies..."
        # Check for duplicate dependencies
        local duplicates=$(awk '/^dependencies:/,/^[^[:space:]]/ {
            if (/^[[:space:]]+[^[:space:]]+:/) {
                gsub(/^[[:space:]]+/, "")
                gsub(/:.*/, "")
                print
            }
        }' "$pubspec_path" | sort | uniq -d)
        
        if [ -n "$duplicates" ]; then
            echo ""
            echo "‚ö†Ô∏è  **Duplicate dependencies detected in $pubspec_path:**"
            echo "$duplicates" | sed 's/^/    ‚Ä¢ /'
            echo ""
            echo "üí° These duplicate entries may cause dependency conflicts."
            echo "üîß Would you like to automatically remove duplicates? (y/N): "
            read REMOVE_DUPLICATES </dev/tty
            if [[ $REMOVE_DUPLICATES =~ ^[Yy]$ ]]; then
                echo ""
                echo "üîß Creating backup: $pubspec_path.backup.$(date +%Y%m%d-%H%M%S)"
                cp "$pubspec_path" "$pubspec_path.backup.$(date +%Y%m%d-%H%M%S)"
                echo "üîß Removing duplicate dependencies..."
                
                # Show which duplicates are being removed
                echo "$duplicates" | while read -r duplicate; do
                    echo "   Removing duplicate: $duplicate"
                done
                
                # Create a temp file with duplicates removed (keep first occurrence)
                awk '
                /^dependencies:/,/^[^[:space:]]/ {
                    if (/^[[:space:]]+[^[:space:]]+:/) {
                        gsub(/^[[:space:]]+/, "")
                        dep = $1
                        gsub(/:.*/, "", dep)
                        if (!seen[dep]) {
                            seen[dep] = 1
                            print
                        }
                    } else {
                        print
                    }
                    next
                }
                { print }
                ' "$pubspec_path" > "$pubspec_path.tmp" && mv "$pubspec_path.tmp" "$pubspec_path"
                
                echo "‚úÖ Successfully removed duplicate dependencies"
            else
                echo "üí° You can manually remove duplicates later if needed"
            fi
        fi
        
        # Check for dependency conflicts
        echo ""
        echo "üîç Checking for dependency conflicts..."
        check_and_resolve_dependency_conflicts "$pubspec_path"
        
        # Check for Git dependency cache issues
        echo ""
        echo "üîÑ Checking Git dependency cache..."
        check_git_dependency_cache "$pubspec_path"
        
        echo "‚úÖ Project validation complete"
    fi
}

# Function to check and refresh Git dependency cache
check_git_dependency_cache() {
    local pubspec_path="$1"
    local project_dir="$(dirname "$pubspec_path")"
    
    if [ ! -f "$pubspec_path" ]; then
        return 0
    fi
    
    # Extract Git dependencies from pubspec.yaml
    local git_deps=$(mktemp_fpm)
    awk '/^[[:space:]]*[^#]*:/{dep_name=$1; gsub(/:/, "", dep_name)} 
         /^[[:space:]]*git:/{in_git=1; next} 
         in_git && /^[[:space:]]*url:/{url=$2; gsub(/["]/, "", url)} 
         in_git && /^[[:space:]]*ref:/{ref=$2; gsub(/["]/, "", ref)} 
         in_git && /^[[:space:]]*[^[:space:]]/ && !/url:/ && !/ref:/ && !/path:/{
             if(dep_name && url) {
                 print dep_name "|" url "|" (ref ? ref : "main")
                 dep_name=""; url=""; ref=""; in_git=0
             }
         }
         /^[^[:space:]]/ && !/dependencies:/ && !/dependency_overrides:/{in_git=0}' "$pubspec_path" > "$git_deps"
    
    if [ ! -s "$git_deps" ]; then
        echo "‚úÖ No Git dependencies found"
        rm -f "$git_deps"
        return 0
    fi
    
    echo "üì¶ Found Git dependencies:"
    echo "   üîÑ Analyzing dependency freshness..."
    local has_stale_deps=false
    local stale_deps=()
    
    while IFS=\| read -r dep_name git_url git_ref; do
        if [ -n "$dep_name" ] && [ -n "$git_url" ]; then
            echo "   $dep_name ($git_ref) from $git_url"
            
            # Check latest commit for any Git repository (works with GitHub, GitLab, etc.)
            echo -n "     üîç Checking latest commit via Git"
            # Use native git command - works with any Git hosting service!
            local latest_commit=$(git ls-remote "$git_url" "$git_ref" 2>/dev/null | cut -c1-7)
            
            if [ -n "$latest_commit" ]; then
                echo " ‚Üí $latest_commit"
                    
                    # Check Flutter's cache to see what commit we have
                    local cache_dir; cache_dir="$(get_pub_cache_dir)"
                    
                    if [ -n "$cache_dir" ]; then
                        echo -n "     üîç Scanning local pub cache"
                        # Look for cached version by package name (much simpler and reliable!)
                        local cached_paths=$(find "$cache_dir" -name "$dep_name-*" -type d 2>/dev/null)
                        echo "‚úì"
                        
                        if [ -n "$cached_paths" ]; then
                            local cached_commit=""
                            for cached_path in $cached_paths; do
                                if [ -d "$cached_path/.git" ]; then
                                    cached_commit=$(cd "$cached_path" && git rev-parse HEAD 2>/dev/null | cut -c1-7)
                                    break
                                fi
                            done
                            
                            if [ -n "$cached_commit" ]; then
                                if [ "$cached_commit" != "$latest_commit" ]; then
                                    echo "     üîÑ Update available: $cached_commit ‚Üí $latest_commit"
                                    has_stale_deps=true
                                    stale_deps+=("$dep_name|$git_url|$git_ref|$cached_commit|$latest_commit")
                                else
                                    echo "     ‚úÖ Up to date: $cached_commit"
                                fi
                            else
                                echo "     ‚ö†Ô∏è  Could not determine cached commit"
                            fi
                        else
                            echo "     üì• Will fetch: ‚Üí $latest_commit"
                            has_stale_deps=true
                            stale_deps+=("$dep_name|$git_url|$git_ref|NEW|$latest_commit")
                        fi
                    fi
                else
                    echo "     üì• Will fetch: ‚Üí $latest_commit (cache not found)"
                    has_stale_deps=true
                    stale_deps+=("$dep_name|$git_url|$git_ref|NEW|$latest_commit")
                fi
            else
                echo " ‚ùå Could not fetch latest commit"
            fi
            echo ""
    done < "$git_deps"
    
    rm -f "$git_deps"
    
    if [ "$has_stale_deps" = true ]; then
        echo ""
        echo "‚ö†Ô∏è  **Stale Git dependencies detected!**"
        echo ""
        echo "üîß **Resolution options:**"
        echo "1. üßπ Clear Flutter cache and fetch latest commits (recommended)"
        echo "2. üéØ Force refresh specific packages only"
        echo "3. üìã Show detailed cache information"
        echo "4. ‚è≠Ô∏è  Skip cache refresh"
        echo ""
        
        echo "Choose option (1-4, default: 1): "
        read CACHE_CHOICE </dev/tty
        CACHE_CHOICE=${CACHE_CHOICE:-1}
        
        case "$CACHE_CHOICE" in
            1)
                refresh_git_dependency_cache "$project_dir" "all" "${stale_deps[@]}"
                ;;
            2)
                select_packages_to_refresh "$project_dir" "${stale_deps[@]}"
                ;;
            3)
                show_detailed_cache_info "${stale_deps[@]}"
                echo ""
                echo "üîß Refresh cache now? (y/N): "
                read REFRESH_NOW </dev/tty
                if [[ $REFRESH_NOW =~ ^[Yy]$ ]]; then
                    refresh_git_dependency_cache "$project_dir" "all" "${stale_deps[@]}"
                fi
                ;;
            4)
                echo "üí° Git dependencies will continue using cached versions"
                ;;
            *)
                echo "‚ùå Invalid choice, skipping cache refresh"
                ;;
        esac
    else
        echo "‚úÖ All Git dependencies are up to date"
    fi
}

# Function to refresh Git dependency cache
refresh_git_dependency_cache() {
    local project_dir="$1"
    local refresh_type="$2"
    shift 2
    local stale_deps=("$@")
    
    echo ""
    echo "üßπ **Refreshing Git dependency cache...**"
    echo ""
    
    cd "$project_dir"
    
    if [ "$refresh_type" = "all" ]; then
        echo "üóëÔ∏è  Clearing Flutter pub cache..."
        flutter pub cache clean
        
        echo "üì¶ Re-fetching all dependencies..."
        flutter pub get
        
        if [ $? -eq 0 ]; then
            echo "‚úÖ **All Git dependencies refreshed successfully!**"
            echo ""
            echo "üîç **Verifying updated commits:**"
            
            # Actually verify the commits after update
            for stale_info in "${stale_deps[@]}"; do
                IFS=\| read -r dep_name git_url git_ref cached_commit latest_commit <<< "$stale_info"
                
                # Find the actual cached commit after update
                local cache_dir; cache_dir="$(get_pub_cache_dir)"
                
                if [ -n "$cache_dir" ]; then
                    local repo_hash=$(echo "$git_url" | shasum | cut -c1-8 2>/dev/null)
                    local cached_paths=$(find "$cache_dir" -name "*$repo_hash*" -type d 2>/dev/null)
                    local actual_commit=""
                    
                    for cached_path in $cached_paths; do
                        if [ -d "$cached_path/.git" ]; then
                            actual_commit=$(cd "$cached_path" && git rev-parse HEAD 2>/dev/null | cut -c1-7)
                            break
                        fi
                    done
                    
                    if [ -n "$actual_commit" ]; then
                        if [ "$actual_commit" = "$latest_commit" ]; then
                            echo "   ‚úÖ $dep_name: $cached_commit ‚Üí $actual_commit (SUCCESS)"
                        else
                            echo "   ‚ö†Ô∏è  $dep_name: $cached_commit ‚Üí $actual_commit (expected $latest_commit)"
                        fi
                    else
                        echo "   ‚ùì $dep_name: Could not verify cached commit"
                    fi
                else
                    echo "   ‚ùì $dep_name: Cache directory not found"
                fi
            done
        else
            echo "‚ùå Failed to refresh dependencies - check for conflicts"
        fi
    else
        # Selective refresh (more complex, requires careful cache manipulation)
        echo "üéØ Selective refresh not yet implemented - using full refresh..."
        flutter pub cache clean
        flutter pub get
    fi
    
    cd - >/dev/null
}

# Function to select specific packages to refresh
select_packages_to_refresh() {
    local project_dir="$1"
    shift
    local stale_deps=("$@")
    
    echo ""
    echo "üéØ **Select packages to refresh:**"
    echo ""
    
    # Show packages that will be updated
    for stale_info in "${stale_deps[@]}"; do
        IFS=\| read -r dep_name git_url git_ref cached_commit latest_commit <<< "$stale_info"
        if [ "$cached_commit" = "NEW" ]; then
            echo "   ‚Ä¢ $dep_name (NEW ‚Üí $latest_commit)"
        else
            echo "   ‚Ä¢ $dep_name ($cached_commit ‚Üí $latest_commit)"
        fi
    done
    
    echo ""
    read -p "üîÑ Update all packages? (y/N): " update_choice </dev/tty
    
    if [[ "$update_choice" =~ ^[Yy]$ ]]; then
        refresh_git_dependency_cache "$project_dir" "all" "${stale_deps[@]}"
    else
        echo "‚è≠Ô∏è  Update skipped"
    fi
}

# Function to show detailed cache information
show_detailed_cache_info() { echo "üìã ${#@} stale Git dependencies found in cache"; }

# Function to analyze and suggest exported functions from a package
analyze_package_exports() { echo "üîç Package analysis: $(basename "$1")"; }
# Function to auto-discover monorepo structure
discover_monorepo_structure() { echo "üèóÔ∏è Monorepo detected: $(find "$1" -name "pubspec.yaml" | wc -l | tr -d " ") packages found"; }
# Function to install missing dependencies
install_dependencies() {
    local missing_deps=()
    local failed_installs=()

    # Check for GitHub CLI
    if ! command -v gh &> /dev/null; then
        missing_deps+=("gh")
    fi

    # Check for jq
    if ! command -v jq &> /dev/null; then
        missing_deps+=("jq")
    fi

    if [ ${#missing_deps[@]} -gt 0 ]; then
        echo "üì¶ Missing required dependencies: ${missing_deps[*]}"
        echo "üîß Attempting automatic installation..."
        echo ""

        for dep in "${missing_deps[@]}"; do
            echo "Installing $dep..."
            if auto_install_package "$dep"; then
                echo "‚úÖ $dep installation completed"
            else
                echo "‚ùå Failed to install $dep automatically"
                failed_installs+=("$dep")
            fi
            echo ""
        done

        # Check if installations were successful
        missing_after_install=()
        for dep in "${missing_deps[@]}"; do
            if ! command -v "$dep" &> /dev/null; then
                missing_after_install+=("$dep")
            fi
        done

        if [ ${#missing_after_install[@]} -gt 0 ]; then
            echo "‚ùå Some dependencies are still missing: ${missing_after_install[*]}"
            echo ""
            echo "Please install them manually using your package manager:"
            echo ""

            for dep in "${missing_after_install[@]}"; do
                echo "For $dep:"
                if [[ "$dep" == "gh" ]]; then
                    echo "  # GitHub CLI installation varies by distribution"
                    echo "  # See: https://cli.github.com for specific instructions"
                    echo "  # Or try these common methods:"
                    suggest_package_install "gh"
                else
                    suggest_package_install "$dep"
                fi
                echo ""
            done
            exit 1
        else
            echo "‚úÖ All dependencies installed successfully!"
            echo ""
        fi
    fi
}

# Check dependencies
install_dependencies

# Function to authenticate with GitHub automatically
authenticate_github() {
    echo "üîê Setting up GitHub authentication..."
    echo ""

    # Open browser first using cascade fallback
    echo "üåê Opening GitHub authentication in your browser..."
    if open "https://github.com/login/device" &>/dev/null; then
        echo "‚úÖ Browser opened successfully"
    elif command -v xdg-open &>/dev/null && xdg-open "https://github.com/login/device" &>/dev/null; then
        echo "‚úÖ Browser opened successfully"
    elif open_browser "https://github.com/login/device"; then
        echo "‚úÖ Browser opened successfully"
    else
        echo "‚ùå Could not open browser automatically."
        echo "üìù Please visit: https://github.com/login/device"
    fi

    echo ""
    echo "üîë Starting authentication process..."
    echo "üí° The GitHub CLI will show you a code to enter in the browser"
    echo ""

    # Create a named pipe to capture the output and display it while running
    TEMP_OUTPUT=$(mktemp_fpm)

    # Run gh auth login and capture output
    {
        gh auth login --web --hostname github.com 2>&1 | tee "$TEMP_OUTPUT"
    } &
    GH_PID=$!

    # Monitor the output for the authentication code
    sleep 2
    while kill -0 $GH_PID 2>/dev/null; do
        if [ -f "$TEMP_OUTPUT" ]; then
            AUTH_CODE=$(grep -oE '[A-Z0-9]{4}-[A-Z0-9]{4}' "$TEMP_OUTPUT" 2>/dev/null | head -1)
            if [ -n "$AUTH_CODE" ] && [ ! -f "/tmp/code_copied_$AUTH_CODE" ]; then
                echo ""
                echo "üìã üéØ Authentication Code Found: $AUTH_CODE"
                echo ""
                echo "üìé Copying code to clipboard..."
                if copy_to_clipboard "$AUTH_CODE"; then
                    echo "‚úÖ Code copied! Switch to your browser and paste it."
                else
                    echo "‚ö†Ô∏è  Please copy manually: $AUTH_CODE"
                fi
                echo ""

                # Mark that we've processed this code
                touch "/tmp/code_copied_$AUTH_CODE"
            fi
        fi
        sleep 1
    done

    # Wait for the gh process to complete
    wait $GH_PID
    GH_EXIT_CODE=$?

    # Clean up
    rm -f "$TEMP_OUTPUT" "/tmp/code_copied_"* 2>/dev/null

    if [ $GH_EXIT_CODE -eq 0 ] && gh auth status &>/dev/null; then
        echo ""
        echo "‚úÖ GitHub authentication successful!"
        return 0
    else
        echo ""
        echo "‚ùå Authentication failed or was cancelled."
        echo ""
        echo "üîß You can try again by running: gh auth login --web"
        echo ""
        return 1
    fi
}

# Universal Git Update Function - works for both self-updates and package updates
universal_git_check() {
    local repo_path="${1:-.}"           # Repository path (default: current directory)
    local target_branch="${2:-main}"    # Target branch (default: main)  
    local expected_commit="${3:-}"       # Optional: specific commit to compare against
    local repo_name="${4:-repository}"  # Display name for the repository
    
    echo "üîç Checking $repo_name for updates..."
    
    # Change to repository directory
    local original_dir=$(pwd)
    if ! cd "$repo_path" 2>/dev/null; then
        echo "‚ùå Cannot access repository: $repo_path"
        return 1
    fi
    
    # Verify this is a git repository  
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "‚ùå Not a Git repository: $repo_path"
        cd "$original_dir"
        return 1
    fi
    
    # Get current commit
    local current_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    local current_short=$(echo "$current_commit" | cut -c1-7)
    
    # Use git remote update for reliable remote sync
    echo "üì° Syncing with remote..."
    git remote -v update >/dev/null 2>&1 || true
    
    # Determine what we're comparing against
    local target_commit=""
    local target_short=""
    local comparison_type=""
    
    if [ -n "$expected_commit" ]; then
        # Specific commit comparison (for package dependencies)
        target_commit="$expected_commit"
        target_short=$(echo "$target_commit" | cut -c1-7)
        comparison_type="specific commit"
    else
        # Branch comparison (for self-updates)
        target_commit=$(git rev-parse "origin/$target_branch" 2>/dev/null || echo "unknown")
        target_short=$(echo "$target_commit" | cut -c1-7)
        comparison_type="remote $target_branch branch"
    fi
    
    echo "üìç Current: $current_short"
    echo "üìç Target:  $target_short ($comparison_type)"
    
    # Compare commits
    if [ "$current_commit" = "$target_commit" ] || [ "$target_commit" = "unknown" ]; then
        echo "‚úÖ $repo_name is up to date"
        cd "$original_dir"
        return 1  # Return 1 to indicate no update needed
    else
        echo "üîÑ Update available: $current_short ‚Üí $target_short"
        
        # Show what would change (for branch updates)
        if [ -z "$expected_commit" ] && [ "$target_commit" != "unknown" ]; then
            echo ""
            echo "üìã Recent changes:"
            git log --oneline --max-count=3 HEAD..origin/$target_branch 2>/dev/null | sed 's/^/   ‚Ä¢ /' || echo "   (Unable to show changes)"
        fi
        
        cd "$original_dir"
        return 0  # Return 0 to indicate update needed
    fi
}

# Universal Git Update Executor - applies the actual update
universal_git_update() {
    local repo_path="${1:-.}"
    local target_branch="${2:-main}"
    local expected_commit="${3:-}"
    local repo_name="${4:-repository}"
    
    echo ""
    echo "üîÑ Updating $repo_name..."
    
    local original_dir=$(pwd)
    if ! cd "$repo_path" 2>/dev/null; then
        echo "‚ùå Cannot access repository: $repo_path"
        return 1
    fi
    
    local success=false
    
    if [ -n "$expected_commit" ]; then
        # Specific commit checkout (for packages)
        if git checkout "$expected_commit" >/dev/null 2>&1; then
            success=true
        fi
    else
        # Branch pull (for self-updates)
        if git pull origin "$target_branch" >/dev/null 2>&1; then
            success=true
        fi
    fi
    
    if [ "$success" = true ]; then
        local new_commit=$(git rev-parse --short HEAD)
        echo "‚úÖ Successfully updated to: $new_commit"
        
        # Verify with git status
        local status_check=$(git status -uno | head -2)
        if echo "$status_check" | grep -q "up to date\|nothing to commit"; then
            echo "üéâ Update completed successfully!"
        fi
    else
        echo "‚ùå Update failed"
        cd "$original_dir"
        return 1
    fi
    
    cd "$original_dir"
    return 0
}

# Function to check for Flutter-PM updates (using universal function)
check_flutter_pm_updates() {
    echo ""
    echo "üîÑ **Flutter Package Manager Update Check**"
    echo "=========================================="
    echo ""
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "‚ùå Flutter-PM is not installed from a Git repository"
        echo "üí° To enable updates, reinstall using the Git installation method"
        echo ""
        return 1
    fi
    
    local current_branch=$(git branch --show-current 2>/dev/null || echo "main")
    echo "üìç Current branch: $current_branch"
    echo ""
    
    # Use universal function for update check
    if universal_git_check "." "$current_branch" "" "Flutter-PM"; then
        echo ""
        read -p "üîÑ Would you like to update now? (y/N): " update_choice </dev/tty
        
        if [[ "$update_choice" =~ ^[Yy]$ ]]; then
            if universal_git_update "." "$current_branch" "" "Flutter-PM"; then
                echo "üí° The updated script will be used on your next run"
            fi
        else
            echo "‚è≠Ô∏è  Update skipped"
        fi
    fi
    
    echo ""
    echo "üìù To manually check status: git status -uno"  
    echo "üìù To manually update: git pull origin $current_branch"
    echo ""
}

# Check if authenticated with GitHub
if ! gh auth status &>/dev/null; then
    echo "‚ùå Not authenticated with GitHub."
    echo ""
    if ! ask_yes_default "üöÄ Would you like to authenticate now?"; then
        echo "‚ÑπÔ∏è  You can authenticate later with: gh auth login"
        exit 1
    fi

    authenticate_github
fi

# Enhanced project discovery with GitHub integration
FLUTTER_PROJECTS=()
SELECTED_PUBSPEC=""
SELECTED_PROJECT=""

# Project selection
# Main loop for handling configuration and project selection
while true; do
    select_project_source

    case $PROJECT_SOURCE_CHOICE in
        3)
            # Configuration
            configure_search_settings
            continue  # Go back to main menu
            ;;
        4)
            # Current directory selected - no need to loop
            break
            ;;
        5)
            # Express Git package update - handle immediately
            SELECTED_PUBSPEC="$DETECTED_PUBSPEC_PATH"
            SELECTED_PROJECT=$(get_project_name)
            echo ""
            echo "üöÄ **Express Git Package Update Mode**"
            echo "======================================"
            echo "üì± Using project: $SELECTED_PROJECT"
            echo ""
            
            check_git_dependency_cache "$SELECTED_PUBSPEC"
            
            echo ""
            echo "‚úÖ **Express update complete!**"
            echo "üéØ Your Git packages are now at the latest commits - ready for development!"
            exit 0
            ;;
        6)
            # Check for Flutter-PM updates
            check_flutter_pm_updates
            continue  # Go back to main menu
            ;;
        *)
            break  # Exit loop for other choices
            ;;
    esac
done

case $PROJECT_SOURCE_CHOICE in
    1)
        # Local directory scan
        echo ""
        echo "üîç Searching for local Flutter projects..."

        # Use configured search paths and settings
        if [ "$CONFIG_FULL_DISK_SEARCH" = "true" ]; then
            echo "‚ö†Ô∏è  Performing full disk search (this may take a while)..."
            while IFS= read -r -d '' project; do
                FLUTTER_PROJECTS+=("$project")
            done < <(find / \( -type d \( -name ".git" -o -name ".dart_tool" -o -name "build" -o -name "node_modules" -o -name "Pods" -o -name ".Trash" -o -path "$SCRIPTS_ROOT" -o -path "$SCRIPTS_ROOT/*" \) -prune \) -o -name "pubspec.yaml" -print0 2>/dev/null)
        else
            for dir in "${CONFIG_SEARCH_PATHS[@]}"; do
                if [ -d "$dir" ]; then
                    echo "üîç Searching in: $dir (depth: $CONFIG_SEARCH_DEPTH)"
                    while IFS= read -r -d '' project; do
                        FLUTTER_PROJECTS+=("$project")
                    done < <(find "$dir" -maxdepth "$CONFIG_SEARCH_DEPTH" \( -type d \( -name ".git" -o -name ".dart_tool" -o -name "build" -o -name "node_modules" -o -name "Pods" -o -name ".Trash" -o -path "$SCRIPTS_ROOT" -o -path "$SCRIPTS_ROOT/*" \) -prune \) -o -name "pubspec.yaml" -print0 2>/dev/null)
                fi
            done
        fi

        if [ ${#FLUTTER_PROJECTS[@]} -eq 0 ]; then
            echo "‚ùå No Flutter projects found in configured directories."
            echo "üí° Try configuring different search paths, enabling full disk search, or use the GitHub fetch option."
            exit 1
        fi
        ;;
    2)
        # GitHub repository fetch
        get_save_location
        if [ $? -ne 0 ]; then
            echo "‚ùå Failed to get save location"
            exit 1
        fi

        if ! fetch_github_project "$PROJECT_SAVE_LOCATION"; then
            echo "‚ùå Failed to fetch GitHub project"
            exit 1
        fi

        if [ ${#FLUTTER_PROJECTS[@]} -eq 0 ]; then
            echo "‚ùå No Flutter projects found in the fetched repository"
            exit 1
        fi
        ;;
    4)
        # Detected project (current or parent directory)
        SELECTED_PUBSPEC="$DETECTED_PUBSPEC_PATH"
        SELECTED_PROJECT=$(basename "$(dirname "$SELECTED_PUBSPEC")")
        echo "üì± Using project: $SELECTED_PROJECT"
        ;;
    *)
        echo "‚ùå Invalid source selection: $PROJECT_SOURCE_CHOICE"
        exit 1
        ;;
esac

# Project selection from found projects (only for options 1 and 2)
if [[ "$PROJECT_SOURCE_CHOICE" == "1" || "$PROJECT_SOURCE_CHOICE" == "2" ]] && [ ${#FLUTTER_PROJECTS[@]} -eq 1 ]; then
    # Only one project found, use it directly
    SELECTED_PUBSPEC="${FLUTTER_PROJECTS[0]}"
    SELECTED_PROJECT=$(basename "$(dirname "$SELECTED_PUBSPEC")")
    echo "üì± Using project: $SELECTED_PROJECT"
elif [[ "$PROJECT_SOURCE_CHOICE" == "1" || "$PROJECT_SOURCE_CHOICE" == "2" ]] && [ ${#FLUTTER_PROJECTS[@]} -gt 1 ]; then
    # Multiple projects found, let user choose
    echo ""
    echo "üìã Found ${#FLUTTER_PROJECTS[@]} Flutter projects:"
    for ((i=0; i<${#FLUTTER_PROJECTS[@]}; i++)); do
        PROJECT_DIR=$(dirname "${FLUTTER_PROJECTS[$i]}")
        PROJECT_NAME=$(basename "$PROJECT_DIR")
        RELATIVE_PATH=$(get_relative_path "$PROJECT_DIR")
        echo "$((i+1)). $PROJECT_NAME ($RELATIVE_PATH)"
    done

    echo ""
    read -p "Enter project number: " PROJECT_NUM </dev/tty

    if [[ ! "$PROJECT_NUM" =~ ^[0-9]+$ ]] || [ "$PROJECT_NUM" -lt 1 ] || [ "$PROJECT_NUM" -gt ${#FLUTTER_PROJECTS[@]} ]; then
        echo "‚ùå Invalid selection"
        exit 1
    fi

    SELECTED_PUBSPEC="${FLUTTER_PROJECTS[$((PROJECT_NUM-1))]}"
    SELECTED_PROJECT=$(basename "$(dirname "$SELECTED_PUBSPEC")")
    echo "üì± Using project: $SELECTED_PROJECT"
fi

# Quick check for existing Git dependencies - offer fast update option
if [ -n "$SELECTED_PUBSPEC" ] && [ -f "$SELECTED_PUBSPEC" ]; then
    # Check if there are any Git dependencies
    if grep -A 3 "git:" "$SELECTED_PUBSPEC" >/dev/null 2>&1; then
        echo ""
        echo "üîÑ **Git Dependencies Detected!**"
        echo ""
        echo "Found existing Git packages in your project. Since you're iterating often on your own repos:"
        echo ""
        echo "üìã **Quick Actions:**"
        echo "1. üöÄ Just update my Git packages (fastest - skip all setup)"
        echo "2. ‚ûï Add new packages (continue with full workflow)"  
        echo "3. üîÑ Update existing + add new packages"
        echo ""
        
        echo "Choose option (1-3, default: 1): "
        read QUICK_ACTION </dev/tty
        QUICK_ACTION=${QUICK_ACTION:-1}
        
        case "$QUICK_ACTION" in
            1)
                echo ""
                echo "üöÄ **Express Git Package Update**"
                echo "================================="
                check_git_dependency_cache "$SELECTED_PUBSPEC"
                echo ""
                echo "‚úÖ **Quick update complete!** Your Git packages are now at the latest commits."
                echo ""
                echo "üéØ Ready to continue development with updated dependencies!"
                exit 0
                ;;
            2)
                echo ""
                echo "‚ûï **Continuing with full workflow to add new packages...**"
                # Continue with normal flow
                ;;
            3)
                echo ""
                echo "üîÑ **Express Update + New Package Addition**"
                echo "=========================================="
                check_git_dependency_cache "$SELECTED_PUBSPEC"
                echo ""
                echo "‚úÖ Existing packages updated!"
                echo ""
                read -t 10 -p "Continue to add new packages? (Y/n, auto-yes in 10s): " add_new </dev/tty 2>/dev/null || add_new="y"
                case "${add_new:-y}" in
                    [Nn]*)
                        echo "‚úÖ Express update complete! Exiting."
                        exit 0
                        ;;
                    *)
                        echo "‚ûï Continuing to add new packages..."
                        echo ""
                        # Continue with normal flow
                        ;;
                esac
                ;;
            *)
                echo "‚ö†Ô∏è  Invalid choice, continuing with full workflow..."
                ;;
        esac
    fi
fi

# Validate the selected project structure
if [ -n "$SELECTED_PUBSPEC" ]; then
    echo ""
    echo "üîç Analyzing project dependencies and structure..."
    validate_project_structure "$(get_project_dir)"
fi

# Get repositories
echo ""
echo "üîç Fetching your repositories..."

# Get repository data as JSON for processing with error handling
REPO_JSON=""
if command -v gh >/dev/null 2>&1; then
    REPO_JSON=$(gh repo list --limit 100 --json name,owner,isPrivate,url,description 2>/dev/null || echo "[]")
else
    echo "‚ùå GitHub CLI not found. Please install gh CLI first:"
    echo "   brew install gh  # macOS"
    echo "   sudo apt install gh  # Ubuntu/Debian"
    exit 1
fi

if [ -z "$REPO_JSON" ] || [ "$REPO_JSON" = "[]" ]; then
    echo "‚ùå No repositories found or GitHub CLI not authenticated"
    echo "üí° Try running: gh auth login"
    exit 1
fi

# Create array of repository display strings (bash 3.x compatible)
REPO_OPTIONS=()
while IFS= read -r line; do
    REPO_OPTIONS+=("$line")
done < <(echo "$REPO_JSON" | jq -r '.[] | "\(.owner.login)/\(.name) (\(if .isPrivate then "private" else "public" end)) - \(.description // "No description")"')

# Create array of repository full names for processing (bash 3.x compatible)
REPO_NAMES=()
while IFS= read -r line; do
    REPO_NAMES+=("$line")
done < <(echo "$REPO_JSON" | jq -r '.[] | "\(.owner.login)/\(.name)"')

if [ ${#REPO_OPTIONS[@]} -eq 0 ]; then
    echo "‚ùå No repositories found"
    exit 1
fi

echo ""
clear

# Show smart recommendations before package selection
echo "ü§ñ **SMART ANALYSIS & RECOMMENDATIONS**"
echo "======================================"
echo ""

# Analyze the selected project for smart recommendations
if [ -n "$SELECTED_PUBSPEC" ]; then
    project_dir="$(dirname "$SELECTED_PUBSPEC")"
    echo "üìä Analyzing your Flutter project for intelligent package suggestions..."
    echo ""
    
    # Run smart recommendations analysis
    analyze_code_patterns "$project_dir"
    
    echo ""
    echo "ü§î **Would you like to add any of the recommended packages?**"
    echo ""
    echo "üìã **Options:**"
    echo "1. ‚úÖ Yes - let me select from recommended packages"
    echo "2. ‚è≠Ô∏è  Skip recommendations - go straight to manual selection"
    echo "3. üö´ Skip all - exit without adding packages"
    echo ""
    
    echo "Choose option (1-3, default: 1): "
    read RECOMMENDATION_CHOICE </dev/tty
    RECOMMENDATION_CHOICE=${RECOMMENDATION_CHOICE:-1}
    
    case "$RECOMMENDATION_CHOICE" in
        1)
            echo ""
            echo "üéØ **Smart Package Deployment**"
            echo "==============================" 
            deploy_smart_recommendations "$project_dir"
            echo ""
            echo "‚úÖ Recommended packages processed!"
            echo ""
            echo "Continue to manual package selection? (Y/n): "
            read CONTINUE_MANUAL </dev/tty
            if [[ "$CONTINUE_MANUAL" =~ ^[Nn]$ ]]; then
                echo "‚úÖ Package management complete!"
                exit 0
            fi
            ;;
        2)
            echo "‚è≠Ô∏è  Skipping recommended packages..."
            ;;
        3)
            echo "üëã Goodbye!"
            exit 0
            ;;
        *)
            echo "‚è≠Ô∏è  Invalid choice, continuing to manual selection..."
            ;;
    esac
    
    echo ""
    echo "‚ö° **Ready for manual package selection!**"
    echo ""
fi


clear
echo "üìã Select repositories to add as packages:"
echo ""

# CRITICAL FIX: When starting from current directory (pubspec.yaml present),
# we missed the terminal initialization that GitHub operations provide.
# We need to simulate what gh commands do to properly initialize terminal input handling.
if [ -f "./pubspec.yaml" ] && [ -n "$SELECTED_PUBSPEC" ]; then
    # We used current directory, so we missed GitHub operations that initialize terminal
    echo "üîß Initializing terminal for interactive selection..."

fi

# Clear screen for clean selection interface
clear

# Use multiselect function
SELECTED_INDICES=()
echo "DEBUG: About to call multiselect with ${#REPO_OPTIONS[@]} options"
multiselect "Select repositories (SPACE to select, ENTER to confirm):" "REPO_OPTIONS" "SELECTED_INDICES" false true
echo "DEBUG: Multiselect returned, selected indices: ${SELECTED_INDICES[*]}"

# Restore terminal to cooked mode before next prompts
reset_tty

if [ ${#SELECTED_INDICES[@]} -eq 0 ]; then
    echo "‚ùå No repositories selected"
    exit 1
fi

echo "DEBUG: Processing ${#SELECTED_INDICES[@]} selected repositories"

echo "üì¶ Selected ${#SELECTED_INDICES[@]} repositories:"
SELECTED_REPOS=()
for idx in "${SELECTED_INDICES[@]}"; do
    echo "  - ${REPO_NAMES[idx]}"
    SELECTED_REPOS+=("${REPO_NAMES[idx]}")
done

# Process each selected repository
echo ""
echo "üîß Processing selected repositories..."

ADDED_PACKAGES=()
FAILED_PACKAGES=()

for REPO_FULL_NAME in "${SELECTED_REPOS[@]}"; do
    echo ""
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    echo "üì¶ Processing: $REPO_FULL_NAME"

    REPO_NAME=$(echo "$REPO_FULL_NAME" | cut -d'/' -f2)
    REPO_URL="https://github.com/$REPO_FULL_NAME.git"

    # Get branches and tags
    echo ""
    echo "üè∑Ô∏è  Available references for $REPO_FULL_NAME:"
    echo "Branches:"
    BRANCHES_OUTPUT=$(gh api "repos/$REPO_FULL_NAME/branches" --jq '.[].name' 2>/dev/null || true)
    if [ -n "$BRANCHES_OUTPUT" ]; then
        echo "$BRANCHES_OUTPUT" | head -10 | sed 's/^/  /'
    else
        echo "  (No branches found or insufficient permissions)"
    fi

    echo "Tags:"
    TAGS_OUTPUT=$(gh api "repos/$REPO_FULL_NAME/tags" --jq '.[].name' 2>/dev/null || true)
    if [ -n "$TAGS_OUTPUT" ]; then
        echo "$TAGS_OUTPUT" | head -10 | sed 's/^/  /'
    else
        echo "  (No tags found)"
    fi

    # Ensure TTY is ready for input prompts
    reset_tty
    
    echo ""
    echo "Specify branch/tag (default: main): "
    read REF </dev/tty
    REF=${REF:-main}

    # Auto-discover monorepo structure
    discover_monorepo_structure "$REPO_FULL_NAME" "$REF"
    
    # Use discovered path or set defaults based on auto-detection
    if [ -n "$MONOREPO_SUB_PATH" ] && [ "$MONOREPO_SUB_PATH" != "." ]; then
        SUB_PATH="$MONOREPO_SUB_PATH"
        echo ""
        echo "üéØ Using auto-discovered monorepo path: $SUB_PATH"
        echo ""
        echo "Override with custom path? (leave empty to use discovered path): "
        read CUSTOM_SUB_PATH </dev/tty
        if [ -n "$CUSTOM_SUB_PATH" ]; then
            SUB_PATH="$CUSTOM_SUB_PATH"
            echo "‚úÖ Using custom override: $SUB_PATH"
        fi
    else
        # Auto-discovery determined single package - use root path
        SUB_PATH=""
        if [ -z "$MONOREPO_SUB_PATH" ]; then
            # Only ask manual input if auto-discovery completely failed
            echo ""
            echo "‚ö†Ô∏è  Auto-discovery failed. Manual input required."
            echo "If this is a monorepo, enter package subfolder path (empty for root): "
            read SUB_PATH </dev/tty
            SUB_PATH=${SUB_PATH:-}
        fi
    fi

    # Auto-detect default package name from repo pubspec on selected ref and path
    DEFAULT_PACKAGE_NAME=""
    if [ -n "$SUB_PATH" ]; then
        SUB_PUBSPEC_PATH="${SUB_PATH%/}/pubspec.yaml"
        DEFAULT_PACKAGE_NAME=$(get_repo_pubspec_name "$REPO_FULL_NAME" "$REF" "$SUB_PUBSPEC_PATH")
    fi
    if [ -z "$DEFAULT_PACKAGE_NAME" ]; then
        DEFAULT_PACKAGE_NAME=$(get_repo_pubspec_name "$REPO_FULL_NAME" "$REF")
    fi
    if [ -z "$DEFAULT_PACKAGE_NAME" ]; then
        DEFAULT_PACKAGE_NAME="$REPO_NAME"
    fi

    # Ask for package name with detected default
    reset_tty
    echo ""
    echo "Package name for $REPO_FULL_NAME (default: $DEFAULT_PACKAGE_NAME): "
    read PACKAGE_NAME </dev/tty
    PACKAGE_NAME=${PACKAGE_NAME:-$DEFAULT_PACKAGE_NAME}

    # Sanitize package name (replace hyphens with underscores, etc.)
    PACKAGE_NAME=$(echo "$PACKAGE_NAME" | sed 's/-/_/g' | sed 's/[^a-zA-Z0-9_]//g')

    # Add to pubspec
    echo ""
    echo "üìù Adding $PACKAGE_NAME to pubspec.yaml..."
    if add_package_to_pubspec "$SELECTED_PUBSPEC" "$PACKAGE_NAME" "$REPO_URL" "$REF" "$SUB_PATH"; then
        ADDED_PACKAGES+=("$PACKAGE_NAME ($REPO_FULL_NAME)")
        echo "‚úÖ Successfully added $PACKAGE_NAME"
        
        # Quick validation check after adding package
        echo "üîç Validating pubspec.yaml after addition..."
        if ! flutter pub get --dry-run >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Potential issue detected with pubspec.yaml"
            echo "üí° This might be due to package name mismatches or dependency conflicts"
            
            echo ""
            echo "üîß Would you like to run automatic validation and fixes? (y/N): "
            read RUN_VALIDATION </dev/tty
            if [[ $RUN_VALIDATION =~ ^[Yy]$ ]]; then
                validate_project_structure "$(get_project_dir)"
            fi
        fi
        
        # Optional: Analyze exports from the added package
        echo ""
        echo "üî¨ Analyze available functions in this package? (y/N): "
        read ANALYZE_EXPORTS </dev/tty
        if [[ $ANALYZE_EXPORTS =~ ^[Yy]$ ]]; then
            analyze_package_exports "$REPO_FULL_NAME" "$PACKAGE_NAME" "$REF"
        fi
    else
        FAILED_PACKAGES+=("$PACKAGE_NAME ($REPO_FULL_NAME)")
        echo "‚ùå Failed to add $PACKAGE_NAME"
    fi
done

echo ""
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "üéâ Package processing complete!"
echo ""

# Check for dependency conflicts and stale Git dependencies after package addition
if [ ${#ADDED_PACKAGES[@]} -gt 0 ]; then
    echo "üîç Running post-installation dependency analysis..."
    echo ""
    
    # Check for dependency conflicts
    echo "üîç Checking for dependency conflicts..."
    check_and_resolve_dependency_conflicts "$SELECTED_PUBSPEC"
    
    # Check for Git dependency cache issues
    echo ""
    echo "üîÑ Checking Git dependency cache..."
    check_git_dependency_cache "$SELECTED_PUBSPEC"
    
    echo ""
    echo "‚úÖ Dependency analysis complete!"
    echo ""
fi

if [ ${#ADDED_PACKAGES[@]} -gt 0 ]; then
    echo "‚úÖ Successfully added ${#ADDED_PACKAGES[@]} packages:"
    for package in "${ADDED_PACKAGES[@]}"; do
        echo "  ‚úì $package"
    done
fi

if [ ${#FAILED_PACKAGES[@]} -gt 0 ]; then
    echo ""
    echo "‚ùå Failed to add ${#FAILED_PACKAGES[@]} packages:"
    for package in "${FAILED_PACKAGES[@]}"; do
        echo "  ‚úó $package"
    done
fi

echo ""
echo "üöÄ Next steps:"
PROJECT_DIR=$(get_project_dir)
echo "  cd $PROJECT_DIR"
echo "  flutter pub get"

# Ask if they want to run pub get automatically
if [ "$(dirname "$SELECTED_PUBSPEC")" = "." ]; then
    echo ""
    read -p "Run 'flutter pub get' now? (y/N): " RUN_PUB_GET </dev/tty
    if [[ $RUN_PUB_GET =~ ^[Yy]$ ]]; then
        echo -n "üì¶ Running flutter pub get"
        flutter pub get > /dev/null 2>&1 &
        local pub_get_pid=$!
        show_progress "" $pub_get_pid
        wait $pub_get_pid
        echo "‚úÖ Dependencies installed!"
    fi
fi

if [ ${#ADDED_PACKAGES[@]} -gt 0 ]; then
    echo ""
    echo "üí´ Import in your Dart code with:"
    for package in "${ADDED_PACKAGES[@]}"; do
        package_name=$(echo "$package" | cut -d' ' -f1)
        echo "  import 'package:$package_name/$package_name.dart';"
    done
fi
